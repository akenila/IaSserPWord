gemini_client = None
current_profile_index = 0
profile_init_failures = [0, 0, 0, 0, 0]
previous_chat_metadata = None

def split_chrome_profile_path(full_path):
    if not full_path:
        return None, None
        
    user_data_index = full_path.find("User Data")
    if user_data_index == -1:
        return full_path, "Default"
    
    user_data_dir = full_path[:user_data_index + len("User Data")]
    
    remaining = full_path[user_data_index + len("User Data"):]
    if remaining.startswith("\\") or remaining.startswith("/"):
        remaining = remaining[1:]
    
    profile_name = remaining if remaining else "Default"
    
    if "\\" in profile_name or "/" in profile_name:
        profile_name = profile_name.split("\\")[0].split("/")[0]
    
    return user_data_dir, profile_name

def get_cookies_from_browser(profile_path):
    if not profile_path:
        update_log("No Chrome profile selected!")
        return None, None
        
    update_log(f"Getting cookies from Chrome profile: {profile_path}")
    
    try:
        service = Service(ChromeDriverManager().install())
        profile_path, name_profile = split_chrome_profile_path(profile_path)
        
        chrome_options = Options()
        chrome_options.add_argument(f"user-data-dir={profile_path}")
        chrome_options.add_argument(f"--profile-directory={name_profile}")
        chrome_options.add_argument("--headless")
        chrome_options.add_argument("--no-sandbox")  # Thêm tùy chọn này
        chrome_options.add_argument("--disable-dev-shm-usage")  # Giảm thiểu lỗi bộ nhớ chia sẻ
        
        update_log(f"Opening Chrome with profile: {profile_path}")
        driver = webdriver.Chrome(options=chrome_options, service=service)
        
        try:
            driver.get("https://gemini.google.com/")
            update_log("Waiting for Gemini page to load...")
            time.sleep(10)
            
            cookies = driver.get_cookies()
            
            secure_1psid = None
            secure_1psidts = None
            
            for cookie in cookies:
                if cookie['name'] == '__Secure-1PSID':
                    secure_1psid = cookie['value']
                elif cookie['name'] == '__Secure-1PSIDTS':
                    secure_1psidts = cookie['value']
            
            if secure_1psid:
                update_log("Found Secure-1PSID cookie")
            else:
                update_log("Could not find Secure-1PSID cookie!")
                
            if secure_1psidts:
                update_log("Found Secure-1PSIDTS cookie")
            else:
                update_log("Could not find Secure-1PSIDTS cookie (may not be required)")
            
            return secure_1psid, secure_1psidts
        
        except Exception as e:
            update_log(f"Error getting cookies: {e}")
            return None, None
        
        finally:
            driver.quit()
            
    except Exception as e:
        update_log(f"Error starting Chrome: {e}")
        return None, None

async def init_gemini_client(profile_path):
    global gemini_client
    
    secure_1psid, secure_1psidts = get_cookies_from_browser(profile_path)
    
    if not secure_1psid:
        update_log("Missing required cookies, cannot initialize Gemini client")
        return False
    
    try:
        gemini_client = GeminiClient(secure_1psid, secure_1psidts)
        await gemini_client.init(timeout=30, auto_close=False, close_delay=300, auto_refresh=False)
        update_log("Gemini client initialized successfully")
        return True
    except Exception as e:
        update_log(f"Error initializing Gemini client: {e}")
        gemini_client = None
        return False

async def generate_image_with_gemini(prompt, output_path, filename):
    global gemini_client, current_profile_index, profile_init_failures, previous_chat_metadata
    valid_profiles = []
    for i, entry in enumerate(chrome_profile_entries):
        if entry.get().strip():
            valid_profiles.append(i)
    
    if not valid_profiles:
        update_log("Error: No valid Chrome profiles found")
        return None
    
    if current_profile_index not in valid_profiles:
        current_profile_index = valid_profiles[0]
    if not gemini_client:
        profile_path = chrome_profile_entries[current_profile_index].get().strip()
        success = await init_gemini_client(profile_path)
        
        if not success:
            profile_init_failures[current_profile_index] += 1
            
            if profile_init_failures[current_profile_index] >= 2:
                profile_init_failures[current_profile_index] = 0
                current_profile_index = (current_profile_index + 1) % 5
                update_log(f"Switching to profile {current_profile_index + 1}")
                previous_chat_metadata = None
            
            profile_path = chrome_profile_entries[current_profile_index].get().strip()
            success = await init_gemini_client(profile_path)
            
            if not success:
                update_log("Failed to initialize Gemini client with any profile")
                return None
    
    try:
        update_log("Generating image with Gemini...")
        
        chat = gemini_client.start_chat(metadata=previous_chat_metadata)
        
        response = await chat.send_message(f"{prompt}\nGenerate a high-quality, photorealistic image.")
        
        previous_chat_metadata = response.metadata
        
        if not response.images or len(response.images) == 0:
            update_log("No images were generated")
            return None
        
        await response.images[0].save(path=output_path, filename=filename, verbose=True)
        
        return os.path.join(output_path, filename)
    
    except Exception as e:
        update_log(f"Error generating image: {e}")
        gemini_client = None
        previous_chat_metadata = None
        return None


def run_async(coro):
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        return loop.run_until_complete(coro)
    finally:
        loop.close()


def validate_required_apis():
    content_model = model_content_var.get()
    image_model = model_image_var.get()
    
    missing_apis = []
    
    if content_model in [1, 2, 3]:
        if not openai_entry.get().strip():
            missing_apis.append("OpenAI")
    elif content_model in [4, 5]:
        if not claude_entry.get().strip():
            missing_apis.append("Claude")
    elif content_model in [6, 7, 8]:
        if not deeseek_entry.get().strip():
            missing_apis.append("Deepseek")
    
    try:
        max_images = int(image_number_entry.get().strip() or "0")
    except ValueError:
        max_images = 0
        
    if max_images > 0:
        if image_model == 1 and not openai_entry.get().strip():
            if "OpenAI" not in missing_apis:
                missing_apis.append("OpenAI")
        elif image_model == 2:
            missing_apis.append("Gemini Profile Path")
            for i in chrome_profile_entries:
                if i.get().strip():
                    missing_apis.remove("Gemini Profile Path")
        elif image_model == 3 and not deeseek_entry.get().strip():
            if "Deepseek" not in missing_apis:
                missing_apis.append("Deepseek")
    
    return missing_apis

def sanitize_filename(text):
    text = unicodedata.normalize('NFKD', text)
    text = ''.join([c for c in text if not unicodedata.combining(c)])
    text = text.lower().strip()
    text = re.sub(r'\s+', '-', text)
    text = re.sub(r'[^\w\-]', '', text)
    return text[:50]


def generate_image(prompt, model_id):
    global current_profile_index
    if model_id == 1:
        api_key = openai_entry.get().strip()
        if not api_key:
            raise ValueError("API key OpenAI không được cung cấp")
        
        client = OpenAI(api_key=api_key)
        response = client.images.generate(
            model="dall-e-3",
            prompt=prompt,
            size="1024x1024",
            quality="standard",
            n=1,
        )
        
        return response.data[0].url
        
    elif model_id == 2:
        temp_filename = f"{uuid.uuid4()}.png"
        folder_path = folder_entry.get().strip()
        
        if not os.path.exists(folder_path):
            os.makedirs(folder_path)
        
        for attempt in range(5):
            try:
                image_path = run_async(
                    generate_image_with_gemini(prompt, folder_path, temp_filename)
                )
                
                if image_path:
                    return f"local:{image_path}"
                    
                update_log(f"Image generation attempt {attempt+1} failed, trying next profile")
                current_profile_index = (current_profile_index + 1) % 5
                
            except Exception as e:
                update_log(f"Error in Gemini image generation (attempt {attempt+1}): {e}")
                current_profile_index = (current_profile_index + 1) % 5
        
        raise ValueError("Failed to generate image with Imagen3 after 5 attempts")   
    elif model_id == 3:
        api_key = deeseek_entry.get().strip()
        if not api_key:
            raise ValueError("API key không được cung cấp")
        
        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
        
        data = {
            "prompt": prompt,
            "width": 1024,
            "height": 1024
        }
        
        response = requests.post(
            "https://api.deepseek.com/v1/images/generations",
            headers=headers,
            json=data
        )
        
        if response.status_code == 200:
            return response.json()["data"][0]["url"]
        else:
            raise ValueError(f"Image generation error: {response.text}")
    else:
        raise ValueError("Model không được hỗ trợ")

def reset_gemini_chat():
    global previous_chat_metadata
    previous_chat_metadata = None
    update_log("Gemini chat context has been reset")

def stop_processing():
    global processing_active, previous_chat_metadata
    processing_active = False
    previous_chat_metadata = None
    update_log("Đã nhận lệnh dừng. Đang dừng sau khi hoàn thành tác vụ hiện tại...")

async def refresh_gemini_session():
    global gemini_client
    
    if gemini_client:
        try:
            update_log("Refreshing Gemini session...")
            await gemini_client.refresh()
            update_log("Gemini session refreshed successfully")
            return True
        except Exception as e:
            update_log(f"Error refreshing Gemini session: {e}")
            return False
    else:
        return False

def process_internal_linking(wordpress_url, username, password, post_id, post_content, post_link, keyword, excel_file, row_idx):
    update_log("Đang xử lý internal linking cho bài viết...")
    
    try:
        soup = BeautifulSoup(post_content, 'html.parser')
        content_text = str(soup)
        modified = False
        
        capitalized_keyword = keyword.capitalize()
        title_case_keyword = keyword.title()
        
        text_elements = soup.find_all(string=True)
        keyword_found = False
        
        for element in text_elements:
            if element.parent is None or element.parent.name in ['script', 'style', 'a']:
                continue
            
            pattern = r'\b' + re.escape(keyword) + r'\b'
            
            match = re.search(pattern, element, re.IGNORECASE)
            if match:
                found_keyword = match.group(0)
                
                new_text = re.sub(pattern, 
                                 f'<a href="{post_link}">{found_keyword}</a>', 
                                 element, 
                                 count=1, 
                                 flags=re.IGNORECASE)
                
                new_fragment = BeautifulSoup(new_text, 'html.parser')
                
                element.replace_with(new_fragment)
                
                modified = True
                update_log(f"Đã thêm self-link cho từ khóa: {found_keyword}")
                keyword_found = True
                break
        
        if not keyword_found:
            update_log(f"Từ khóa {keyword} không có trong nội dung bài viết")

        content_text = str(soup)
        
        wb = openpyxl.load_workbook(excel_file)
        ws = wb.active
        
        keywords_and_links = []
        for r in range(2, ws.max_row + 1):
            kw = ws.cell(row=r, column=1).value
            internal_link = ws.cell(row=r, column=7).value
            
            if kw and kw.strip() and internal_link and internal_link.strip() and kw.strip().lower() != keyword.lower():
                keywords_and_links.append((kw.strip(), internal_link.strip()))
        
        if not keywords_and_links:
            update_log("Không tìm thấy từ khóa nào phù hợp để tạo internal link")
            ws.cell(row=row_idx, column=6, value=post_link)
            wb.save(excel_file)
            return
        
        try:
            min_links = int(number_entry1.get().strip() or "1")
            max_links = int(number_entry2.get().strip() or "3")
            if min_links > max_links:
                min_links, max_links = max_links, min_links
            max_possible = min(max_links, len(keywords_and_links))
            num_links = min_links + int(time.time() % (max_possible - min_links + 1))
        except ValueError:
            num_links = min(3, len(keywords_and_links))
            
        update_log(f"Chọn {num_links} từ khóa khác nhau để tạo internal links")
        
        selected_keywords = []
        timestamp = int(time.time())
        indices_used = set()
        
        for i in range(num_links):
            if len(indices_used) >= len(keywords_and_links):
                break
                
            current_idx = (timestamp + i) % len(keywords_and_links)
            attempt = 0
            while current_idx in indices_used and attempt < len(keywords_and_links):
                current_idx = (current_idx + 1) % len(keywords_and_links)
                attempt += 1
                
            indices_used.add(current_idx)
            selected_keywords.append(keywords_and_links[current_idx])
        
        keywords_found = 0
        template_keywords = []
        
        for random_kw, random_link in selected_keywords:
            capitalized_random_kw = random_kw.capitalize()
            title_case_random_kw = random_kw.title()
            random_kw_found = False
            
            text_elements = soup.find_all(string=True)
            
            for element in text_elements:
                if element.parent is None or element.parent.name in ['script', 'style', 'a']:
                    continue
                
                pattern = r'\b' + re.escape(random_kw) + r'\b'
                
                match = re.search(pattern, element, re.IGNORECASE)
                if match:
                    found_keyword = match.group(0)
                    
                    new_text = re.sub(pattern, 
                                    f'<a href="{random_link}">{found_keyword}</a>', 
                                    element, 
                                    count=1, 
                                    flags=re.IGNORECASE)
                    
                    new_fragment = BeautifulSoup(new_text, 'html.parser')
                    
                    element.replace_with(new_fragment)
                    
                    content_text = str(soup)
                    
                    modified = True
                    keywords_found += 1
                    update_log(f"Đã thêm internal link cho từ khóa: {found_keyword}")
                    random_kw_found = True
                    break
            
            if not random_kw_found:
                template_keywords.append((random_kw, random_link, title_case_random_kw))
        
        if template_keywords:
            templates = []
            if text_entry1.get().strip():
                templates.append(text_entry1.get().strip())
            if text_entry2.get().strip():
                templates.append(text_entry2.get().strip())
            if text_entry3.get().strip():
                templates.append(text_entry3.get().strip())
            
            if not templates:
                templates = ["Bạn có thể quan tâm", "Xem thêm", "Đọc thêm"]
                
            h2_tags = soup.find_all('h2')
            if len(h2_tags) > 1:
                mid_point = len(h2_tags) // 2
                target_headings = h2_tags[mid_point:mid_point+len(template_keywords)]
                
                blocks_added = 0
                for idx, (_, random_link, title_case_random_kw) in enumerate(template_keywords):
                    if idx >= len(target_headings):
                        break
                    
                    heading = target_headings[idx]
                    
                    template = templates[int(time.time() + idx) % len(templates)]
                    linked_keyword = f'<a href="{random_link}">{title_case_random_kw}</a>'
                    text_content = f"{template}: {linked_keyword}"
                    
                    new_p = soup.new_tag('p')
                    new_p.string = ""
                    
                    heading.insert_before(new_p)
                    blocks_added += 1
                
                if blocks_added > 0:
                    content_text = str(soup)
                    
                    for idx, (_, random_link, title_case_random_kw) in enumerate(template_keywords[:blocks_added]):
                        template_idx = int((time.time() + idx) % len(templates))
                        template = templates[template_idx]
                        linked_keyword = f'<a href="{random_link}">{title_case_random_kw}</a>'
                        text_content = f"{template}: {linked_keyword}"
                        content_text = content_text.replace("<p></p>", f"<p>{text_content}</p>", 1)
                    
                    soup = BeautifulSoup(content_text, 'html.parser')
                    content_text = str(soup)
                    
                    modified = True
                    update_log(f"Đã thêm {blocks_added} text block với internal links")
            else:
                update_log("Không tìm thấy đủ tiêu đề để thêm text block")
        
        if modified:
            update_url = f"{wordpress_url}/wp-json/wp/v2/posts/{post_id}"
            update_data = {'content': content_text}
            
            update_response = requests.post(
                update_url,
                auth=HTTPBasicAuth(username, password),
                json=update_data
            )
            
            if update_response.status_code == 200:
                update_log("Cập nhật internal linking thành công.")
                
                ws.cell(row=row_idx, column=6, value=post_link)
                wb.save(excel_file)
            else:
                update_log(f"Không thể cập nhật internal linking: {update_response.status_code}")
        else:
            ws.cell(row=row_idx, column=6, value=post_link)
            wb.save(excel_file)
            update_log("Không có internal link nào được thêm vào.")
    
    except Exception as e:
        update_log(f"Lỗi khi xử lý internal linking: {str(e)}")
def process_post_and_add_images(wordpress_url, username, password, post_id, post_content, image_model_id, max_images, folder_path):
    if max_images <= 0:
        update_log("Số lượng ảnh là 0, bỏ qua chức năng tạo ảnh")
        return
    
    update_log(f"Đang xử lý bài viết để thêm hình ảnh (tối đa {max_images} ảnh)...")
    
    soup = BeautifulSoup(post_content, 'html.parser')
    
    headings = soup.find_all(['h2'])
    
    images_to_process = []
    
    for heading in headings:
        if len(images_to_process) >= max_images:
            break
        
        heading_text = heading.get_text().strip()
        
        next_p = heading.find_next('p')
        if not next_p:
            continue
        
        paragraph_text = next_p.get_text().strip()
        
        prompt = f"{heading_text}\n{paragraph_text}"
        
        images_to_process.append({
            'heading': heading,
            'heading_text': heading_text,
            'prompt': prompt
        })
    
    if not images_to_process:
        update_log("Không tìm thấy headings phù hợp để tạo ảnh")
        return
    
    if image_model_id == 2:
        process_imagen_batch(wordpress_url, username, password, post_id, soup, images_to_process, max_images, folder_path)
    else:
        process_regular_images(wordpress_url, username, password, post_id, soup, images_to_process, image_model_id, max_images, folder_path)

def process_imagen_batch(wordpress_url, username, password, post_id, soup, images_to_process, max_images, folder_path):
    global gemini_client, previous_chat_metadata, current_profile_index
    
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
    
    if not gemini_client:
        for i, entry in enumerate(chrome_profile_entries):
            if entry.get().strip():
                profile_path = entry.get().strip()
                success = run_async(init_gemini_client(profile_path))
                if success:
                    current_profile_index = i
                    break
        if not gemini_client:
            update_log("Không thể khởi tạo Gemini client")
            return
    
    images_added = 0
    modified = False
    uploaded_images = []
    
    for img_data in images_to_process:
        if images_added >= max_images:
            break
        
        heading = img_data['heading']
        heading_text = img_data['heading_text']
        prompt = img_data['prompt']
        
        tries_remaining = 3
        image_generated = False
        
        while tries_remaining > 0 and not image_generated:
            try:
                update_log(f"Đang tạo ảnh cho: {heading_text} (lần thử {4-tries_remaining}/3)")
                
                temp_filename = f"{uuid.uuid4()}.png"
                
                if gemini_client:
                    chat = gemini_client.start_chat(metadata=previous_chat_metadata)
                    
                    response = run_async(chat.send_message(f"{prompt}\nGenerate a high-quality, photorealistic image."))
                    
                    previous_chat_metadata = response.metadata
                    
                    if not response.images or len(response.images) == 0:
                        update_log(f"Không có ảnh được tạo cho: {heading_text}")
                        tries_remaining -= 1
                        continue
                    
                    run_async(response.images[0].save(path=folder_path, filename=temp_filename))
                    
                    sanitized_heading = sanitize_filename(heading_text)
                    new_filename = f"{sanitized_heading}.png"
                    new_file_path = os.path.join(folder_path, new_filename)
                    
                    if os.path.exists(new_file_path):
                        timestamp = int(time.time())
                        new_filename = f"{sanitized_heading}-{timestamp}.png"
                        new_file_path = os.path.join(folder_path, new_filename)
                    
                    os.rename(os.path.join(folder_path, temp_filename), new_file_path)
                    
                    with open(new_file_path, 'rb') as img:
                        upload_url = f"{wordpress_url}/wp-json/wp/v2/media"
                        files = {'file': (new_filename, img, 'image/png')}
                        
                        upload_response = requests.post(
                            upload_url,
                            auth=HTTPBasicAuth(username, password),
                            files=files
                        )
                        
                        if upload_response.status_code != 201:
                            update_log(f"Không thể tải ảnh lên WordPress: {upload_response.text}")
                            tries_remaining -= 1
                            continue
                        
                        media_data = upload_response.json()
                        media_id = media_data['id']
                        uploaded_images.append(media_id)
                        media_url = media_data['source_url']
                    
                    img_tag = soup.new_tag('img')
                    img_tag['src'] = media_url
                    img_tag['alt'] = heading_text
                    img_tag['class'] = f'wp-image-{media_id}'
                    
                    figure_tag = soup.new_tag('figure')
                    figure_tag['class'] = 'wp-block-image size-full'
                    figure_tag.append(img_tag)
                    
                    heading.insert_after(figure_tag)
                    
                    images_added += 1
                    modified = True
                    image_generated = True
                    update_log(f"Đã thêm ảnh thứ {images_added}/{max_images} vào bài viết")
                else:
                    update_log("Gemini client không khả dụng, đang thử khởi tạo lại...")
                    profile_path = chrome_profile_entries[current_profile_index].get().strip()
                    success = run_async(init_gemini_client(profile_path))
                    if not success:
                        tries_remaining -= 1
                
            except Exception as e:
                update_log(f"Lỗi khi tạo ảnh: {str(e)}")
                tries_remaining -= 1
                gemini_client = None
                
                if tries_remaining == 0:
                    current_profile_index = (current_profile_index + 1) % 5
                    update_log(f"Lỗi - chuyển sang profile {current_profile_index + 1}")
                    
                    for _ in range(5):
                        profile_path = chrome_profile_entries[current_profile_index].get().strip()
                        if profile_path:
                            success = run_async(init_gemini_client(profile_path))
                            if success:
                                previous_chat_metadata = None
                                tries_remaining = 1
                                break
                        current_profile_index = (current_profile_index + 1) % 5
    
    if modified:
        updated_content = str(soup)
        
        update_url = f"{wordpress_url}/wp-json/wp/v2/posts/{post_id}"
        update_data = {'content': updated_content}
        
        update_response = requests.post(
            update_url,
            auth=HTTPBasicAuth(username, password),
            json=update_data
        )
        
        if update_response.status_code == 200:
            update_log(f"Đã cập nhật bài viết với {images_added} hình ảnh")
        else:
            update_log(f"Không thể cập nhật bài viết: {update_response.text}")
    if uploaded_images:
        featured_image_id = uploaded_images[0]
        update_data = {'featured_media': featured_image_id}
        update_response = requests.post(
            f"{wordpress_url}/wp-json/wp/v2/posts/{post_id}",
            auth=HTTPBasicAuth(username, password),
            json=update_data
        )
        if update_response.status_code == 200:
            update_log("Đã đặt ảnh bìa cho bài viết")
        else:
            update_log("Không thể đặt ảnh bìa cho bài viết")
    else:
        update_log("Không có ảnh nào được thêm vào bài viết")
def process_regular_images(wordpress_url, username, password, post_id, soup, images_to_process, image_model_id, max_images, folder_path):
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
    
    images_added = 0
    modified = False
    uploaded_images = []
    
    for img_data in images_to_process:
        if images_added >= max_images:
            break
        
        heading = img_data['heading']
        heading_text = img_data['heading_text']
        prompt = img_data['prompt']
        
        try:
            update_log(f"Tạo ảnh cho đề mục: {heading_text}")
            
            image_result = generate_image(prompt, image_model_id)
            
            if not image_result:
                update_log(f"Không thể tạo ảnh cho đề mục: {heading_text}")
                continue
            
            if image_result.startswith("local:"):
                file_path = image_result[6:]
                sanitized_heading = sanitize_filename(heading_text)
                
                new_filename = f"{sanitized_heading}.png"
                new_file_path = os.path.join(folder_path, new_filename)
                
                if os.path.exists(new_file_path):
                    timestamp = int(time.time())
                    new_filename = f"{sanitized_heading}-{timestamp}.png"
                    new_file_path = os.path.join(folder_path, new_filename)
                
                os.rename(file_path, new_file_path)
                file_path = new_file_path
                
                update_log(f"Đã lưu ảnh tại: {file_path}")
            else:
                image_url = image_result
                
                response = requests.get(image_url)
                if response.status_code != 200:
                    update_log(f"Không thể tải ảnh từ URL: {image_url}")
                    continue
                
                sanitized_heading = sanitize_filename(heading_text)
                filename = f"{sanitized_heading}.jpg"
                file_path = os.path.join(folder_path, filename)
                
                with open(file_path, 'wb') as f:
                    f.write(response.content)
                
                update_log(f"Đã lưu ảnh tại: {file_path}")
            
            upload_url = f"{wordpress_url}/wp-json/wp/v2/media"
            
            with open(file_path, 'rb') as img:
                file_ext = os.path.splitext(file_path)[1].lower()
                mime_type = 'image/jpeg' if file_ext in ['.jpg', '.jpeg'] else 'image/png'
                
                files = {'file': (os.path.basename(file_path), img, mime_type)}
                
                upload_response = requests.post(
                    upload_url,
                    auth=HTTPBasicAuth(username, password),
                    files=files
                )
                
                if upload_response.status_code != 201:
                    update_log(f"Không thể tải ảnh lên WordPress: {upload_response.text}")
                    continue
                
                media_data = upload_response.json()
                media_id = media_data['id']
                media_url = media_data['source_url']
                uploaded_images.append(media_id)
            
            img_tag = soup.new_tag('img')
            img_tag['src'] = media_url
            img_tag['alt'] = heading_text
            img_tag['class'] = f'wp-image-{media_id}'

            figure_tag = soup.new_tag('figure')
            figure_tag['class'] = 'wp-block-image size-full'
            figure_tag.append(img_tag)

            heading.insert_after(figure_tag)
            
            images_added += 1
            modified = True
            update_log(f"Đã thêm ảnh thứ {images_added}/{max_images} vào bài viết")
            
        except Exception as e:
            update_log(f"Lỗi khi xử lý ảnh: {str(e)}")
            continue
    
    if modified:
        updated_content = str(soup)
        
        update_url = f"{wordpress_url}/wp-json/wp/v2/posts/{post_id}"
        update_data = {'content': updated_content}
        
        update_response = requests.post(
            update_url,
            auth=HTTPBasicAuth(username, password),
            json=update_data
        )
        
        if update_response.status_code == 200:
            update_log(f"Đã cập nhật bài viết với {images_added} hình ảnh")
        else:
            update_log(f"Không thể cập nhật bài viết: {update_response.text}")
    else:
        update_log("Không có ảnh nào được thêm vào bài viết")
    
    if uploaded_images:
        featured_image_id = uploaded_images[0]
        update_data = {'featured_media': featured_image_id}
        update_response = requests.post(
            f"{wordpress_url}/wp-json/wp/v2/posts/{post_id}",
            auth=HTTPBasicAuth(username, password),
            json=update_data
        )
        if update_response.status_code == 200:
            update_log("Đã đặt ảnh bìa cho bài viết")
        else:
            update_log("Không thể đặt ảnh bìa cho bài viết")

def generate_content(model_id, prompt, keyword):
    outline_prompt = f"""
    {prompt}
    
    Hãy tạo một bố cục chi tiết cho bài viết về chủ đề "{keyword}" với:
    1. Phần giới thiệu chi tiết (khoảng 300 từ) giới thiệu về chủ đề và tại sao nó quan trọng, không nhắc lại yêu cầu của tôi mà chỉ tập trung vào chủ đề.
    2. Ít nhất 8-10 tiêu đề chính (<h2>) với mô tả ngắn về nội dung của mỗi phần.
    3. Ít nhất 3-4 tiêu đề phụ (<h3>) cho mỗi tiêu đề chính.
    
    Format phản hồi:
    - Phần giới thiệu phải là đoạn văn HTML hoàn chỉnh với thẻ <p>.
    - Mỗi tiêu đề chính phải sử dụng thẻ <h2>.
    - Mỗi tiêu đề phụ phải sử dụng thẻ <h3>.
    - Thêm mô tả ngắn cho mỗi tiêu đề để tôi hiểu nội dung sẽ bao gồm những gì.
    
    VUI LÒNG GIỮ NGUYÊN TẤT CẢ CÁC THẺ HTML.
    """
    
    update_log("Đang tạo bố cục và phần giới thiệu...")
    outline_content = generate_content_with_model(model_id, outline_prompt)
    
    soup = BeautifulSoup(outline_content, 'html.parser')
    h2_tags = soup.find_all('h2')
    
    if len(h2_tags) < 4:
        update_log("Không thể phân tích bố cục, thử tạo lại...")
        return generate_content(model_id, prompt, keyword)
    
    quarter_index = len(h2_tags) // 3
    first_quarter_h2s = h2_tags[:quarter_index]
    second_quarter_h2s = h2_tags[quarter_index:quarter_index * 2]
    third_quarter_h2s = h2_tags[quarter_index * 2:quarter_index * 3]
    
    introduction = ""
    intro_p = soup.find('p')
    if intro_p:
        introduction = str(intro_p)
    else:
        for element in soup.contents:
            if element.name != 'h2' and str(element).strip():
                introduction += str(element)
            else:
                break
    
    def develop_section(h2_tags, section_name):
        titles = [h2.text.strip() for h2 in h2_tags]
        section_prompt = f"""
        {prompt}
        
        Hãy phát triển chi tiết {section_name} của bài viết về "{keyword}" với những tiêu đề sau:
        
        {', '.join(titles)}
        
        Yêu cầu:
        1. Dành ít nhất 500-600 từ cho mỗi tiêu đề chính.
        2. Sử dụng ít nhất 2-3 tiêu đề phụ (<h3>) cho mỗi tiêu đề chính.
        3. Bao gồm ví dụ cụ thể, dữ liệu, và phân tích chuyên sâu.
        4. Dùng các thẻ <p> cho đoạn văn, <ul><li> cho danh sách, <strong> để nhấn mạnh.
        5. Loại bỏ các đoạn văn mặc định không tự nhiên, đầu ra sẽ chỉ chứa nội dung định dạng html, đủ nội dung, nếu quá dài có thể dừng thay vì viết giữa chừng, không sử dụng các ký tự như # ở đầu dòng.
        
        VUI LÒNG GIỮ NGUYÊN TẤT CẢ CÁC THẺ HTML.
        """
        return generate_content_with_model(model_id, section_prompt)
    
    update_log("Đang phát triển phần 1 của thân bài...")
    first_section_content = develop_section(first_quarter_h2s, "phần đầu tiên")
    if first_section_content.find('```html')==-1:
        print("Không tìm thấy text html trong phần 1")
        pass
    else:
        first_section_content = first_section_content.split('```html')[1].split('```')[0]
    
    update_log("Đang phát triển phần 2 của thân bài...")
    second_section_content = develop_section(second_quarter_h2s, "phần thứ hai")
    if second_section_content.find('```html')==-1:
        print("Không tìm thấy text html trong phần 2")
        pass
    else:
        second_section_content = second_section_content.split('```html')[1].split('```')[0]

    third_section_content = develop_section(third_quarter_h2s, "phần thứ ba")
    if third_section_content.find('```html')==-1:
        print("Không tìm thấy text html trong phần 3")
        pass
    else:
        third_section_content = third_section_content.split('```html')[1].split('```')[0]

    
    conclusion_prompt = f"""
    {prompt}
    
    Hãy viết một phần kết luận ngắn gọn về "{keyword}" với các yêu cầu sau:
    1. Tiêu đề phần kết luận phải sử dụng thẻ <h2>Kết luận</h2>.
    2. Độ dài phần kết luận chỉ gồm 2 đoạn văn dài.
    3. Tóm tắt ngắn gọn các điểm chính đã được đề cập trong bài viết.
    4. Câu cuối phải gây ấn tượng mạnh, thúc đẩy người đọc suy nghĩ hoặc hành động.
    
    VUI LÒNG GIỮ NGUYÊN TẤT CẢ CÁC THẺ HTML.
    """
    
    update_log("Đang tạo phần kết luận...")
    conclusion_content = generate_content_with_model(model_id, conclusion_prompt)
    
    update_log("Đang kết hợp các phần nội dung...")
    full_content = f"""
    {introduction}
    
    {first_section_content}
    
    {second_section_content}
    
    {third_section_content}
    
    {conclusion_content}
    """
    
    full_content = full_content.replace("##", "<h2>").replace("###", "<h3>")
    
    update_log("Hoàn thành tạo nội dung!")
    return full_content

def generate_content_with_model(model_id, prompt):
    if model_id in [1, 2, 3]:
        api_key = openai_entry.get().strip()
        if not api_key:
            raise ValueError("API key OpenAI không được cung cấp")
        
        model_name = {
            1: "gpt-4",
            2: "gpt-4o-mini",
            3: "gpt-4o"
        }.get(model_id)
        
        client = OpenAI(api_key=api_key)
        response = client.chat.completions.create(
            model=model_name,
            messages=[{"role": "user", "content": prompt}],
        )
        
        return response.choices[0].message.content
    
    elif model_id in [4, 5]:
        api_key = claude_entry.get().strip()
        if not api_key:
            raise ValueError("API key Claude không được cung cấp")
        
        model_name = {
            4: "claude-3-5-sonnet-20240620",
            5: "claude-3-7-sonnet-20240307"
        }.get(model_id)
        
        client = Anthropic(api_key=api_key)
        response = client.messages.create(
            model=model_name,
            max_tokens=4000,
            messages=[{"role": "user", "content": prompt}]
        )
        
        return response.content[0].text
    
    elif model_id in [6, 7, 8]:
        api_key = deeseek_entry.get().strip()
        if not api_key:
            raise ValueError("API key Deepseek không được cung cấp")
        
        model_name = {
            6: "deepseek-chat",
            7: "deepseek-v3",
            8: "deepseek-r1"
        }.get(model_id)
        
        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
        
        data = {
            "model": model_name,
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": 4000
        }
        
        response = requests.post(
            "https://api.deepseek.com/v1/chat/completions",
            headers=headers,
            json=data
        )
        
        if response.status_code == 200:
            return response.json()["choices"][0]["message"]["content"]
        else:
            raise ValueError(f"Deepseek API error: {response.text}")
    
    else:
        raise ValueError(f"Model ID {model_id} không được hỗ trợ")

def save_excel_without_indices(df, filename):
    try:
        wb = openpyxl.Workbook()
        ws = wb.active
        
        for r_idx, row in enumerate(df.values):
            for c_idx, value in enumerate(row):
                if value is None or (isinstance(value, float) and math.isnan(value)):
                    value = ""
                ws.cell(row=r_idx+1, column=c_idx+1, value=value)
        
        wb.save(filename)
        update_log(f"Đã lưu Excel thành công: {os.path.basename(filename)}")
        return True
    except Exception as e:
        update_log(f"Lỗi khi lưu file Excel: {str(e)}")
        return False

def start_processing():
    def run():
        global processing_active
        processing_active = True
        
        excel_file = data_input_entry.get().strip()
        wordpress_url = url_entry.get().strip()
        username = username_entry.get().strip()
        password = password_entry.get()
        
        if not excel_file or not wordpress_url or not username or not password:
            update_log("Vui lòng nhập đầy đủ thông tin WordPress và file Excel")
            return
        missing_apis = validate_required_apis()
        if missing_apis:
            update_log(f"Nhập thiếu API: {', '.join(missing_apis)}")
            return
            
        selected_categories = []
        for widget in scrollable_frame.winfo_children():
            if isinstance(widget, tk.Checkbutton) and widget.var.get() == 1:
                category_id = widget.category_id
                selected_categories.append(category_id)
        
        if not selected_categories:
            update_log("Vui lòng chọn ít nhất một danh mục")
            return
        
        content_model = model_content_var.get()
        if content_model == 0:
            update_log("Vui lòng chọn model để tạo nội dung")
            return
            
        try:
            wb = openpyxl.load_workbook(excel_file)
            ws = wb.active
            update_log(f"Đã tải file Excel: {os.path.basename(excel_file)}")
            
            if ws.max_column < 5:
                update_log(f"File Excel cần có ít nhất 5 cột (A-E). Hiện tại chỉ có {ws.max_column} cột.")
                return
                
        except Exception as e:
            update_log(f"Lỗi khi tải file Excel: {str(e)}")
            return
            
        consecutive_empty_keywords = 0
        
        for row_idx in range(2, ws.max_row + 1):
            if not processing_active:
                update_log("Đã dừng xử lý theo yêu cầu.")
                return
                
            keyword_cell = ws.cell(row=row_idx, column=1).value
            keyword = str(keyword_cell).strip() if keyword_cell else ""
            
            status_cell = ws.cell(row=row_idx, column=5).value
            status = str(status_cell).strip() if status_cell else ""
            
            if status and status.lower() in ['public', 'draft', 'publish']:
                update_log(f"Bỏ qua dòng {row_idx}: đã có trạng thái '{status}'")
                consecutive_empty_keywords = 0
                continue
                
            if not keyword or keyword.lower() == 'nan' or keyword.lower() == 'none':
                consecutive_empty_keywords += 1
                update_log(f"Dòng {row_idx} không có từ khóa (lần thứ {consecutive_empty_keywords}/3)")
                
                if consecutive_empty_keywords >= 3:
                    update_log("Đã phát hiện 3 dòng liên tiếp không có từ khóa. Dừng xử lý.")
                    return
                continue
            else:
                consecutive_empty_keywords = 0
                
            title_cell = ws.cell(row=row_idx, column=2).value
            title = str(title_cell).strip() if title_cell else ""
            
            prompt_cell = ws.cell(row=row_idx, column=3).value
            prompt = str(prompt_cell).strip() if prompt_cell else ""
            
            url_slug_cell = ws.cell(row=row_idx, column=4).value
            url_slug = str(url_slug_cell).strip() if url_slug_cell else ""
            
            update_log(f"Đang tạo nội dung cho từ khóa: {keyword}")

            content = None
            error_message = None

            for attempt in range(3):
                try:
                    update_log(f"Lần thử {attempt+1}/3...")
                    content = generate_content(content_model, prompt, keyword)
                    if content:
                        break
                except Exception as e:
                    error_message = str(e)
                    update_log(f"Lỗi khi tạo nội dung: {error_message}")
                    time.sleep(2)
            
            if not content:
                update_log("Không thể tạo nội dung sau 3 lần thử. Dừng xử lý.")
                ws.cell(row=row_idx, column=5, value="Lỗi: Không thể tạo nội dung")
                
                wb.save(excel_file)
                return

            post_data = {
                'title': title,
                'content': content,
                'status': 'draft' if posting_mode_var.get() == 2 else 'publish',
                'categories': selected_categories
            }

            if url_slug:
                post_data['slug'] = url_slug
                
            post_url = f"{wordpress_url}/wp-json/wp/v2/posts"
            
            try:
                response = requests.post(
                    post_url,
                    auth=HTTPBasicAuth(username, password),
                    json=post_data,
                    timeout=30
                )
                
                if response.status_code in [200, 201]:
                    post_data = response.json()
                    post_link = post_data.get('link', '')
                    post_id = post_data.get('id')
                    
                    status_value = 'Draft' if posting_mode_var.get() == 2 else 'Publish'
                    ws.cell(row=row_idx, column=5, value=status_value)
                    ws.cell(row=row_idx, column=6, value=post_link)


                    if toggle_var.get():
                        process_internal_linking(
                            wordpress_url,
                            username,
                            password,
                            post_id,
                            content,
                            post_link,
                            keyword,
                            excel_file,
                            row_idx
                        )
                    
                    try:
                        image_model = model_image_var.get()
                        max_images = 0
                        try:
                            max_images = int(image_number_entry.get().strip() or "0")
                        except ValueError:
                            update_log("Số lượng ảnh không hợp lệ, bỏ qua chức năng tạo ảnh")
                            
                        folder_path = folder_entry.get().strip()
                        
                        if image_model > 0 and max_images > 0 and folder_path:
                            if not os.path.exists(folder_path):
                                os.makedirs(folder_path)
                            get_post_url = f"{wordpress_url}/wp-json/wp/v2/posts/{post_id}"
                            response = requests.get(
                                get_post_url,
                                auth=HTTPBasicAuth(username, password)
                            )

                            if response.status_code == 200:
                                updated_content = response.json()['content']['rendered']
                                
                                process_post_and_add_images(
                                    wordpress_url, 
                                    username, 
                                    password, 
                                    post_id, 
                                    updated_content,
                                    image_model, 
                                    max_images, 
                                    folder_path
                                )
                    except Exception as e:
                        update_log(f"Lỗi khi thêm hình ảnh: {str(e)}")
                    update_log(f"Đã đăng bài '{title}' thành công! Link: {post_link}")
                else:
                    error_msg = f"Lỗi: Mã {response.status_code}"
                    update_log(f"Lỗi khi đăng bài: {error_msg}")
                    ws.cell(row=row_idx, column=5, value=error_msg)
                    
                    wb.save(excel_file)
                    return
            except Exception as e:
                error_msg = f"Lỗi: {str(e)}"
                update_log(f"Lỗi khi đăng bài: {error_msg}")
                ws.cell(row=row_idx, column=5, value=error_msg)
                wb.save(excel_file)
                return
            
            wb.save(excel_file)
            time.sleep(2)
            
        update_log("Đã hoàn thành tất cả các bài viết!")
    
    threading.Thread(target=run).start()

def load_data():
    file_path = filedialog.askopenfilename(
        title="Select Configuration File",
        filetypes=[("JSON Files", "*.json"), ("All Files", "*.*")]
    )
    
    if not file_path:
        return
    
    try:
        if os.path.exists(file_path):
            with open(file_path, "r", encoding="utf-8") as f:
                config = json.load(f)
                
            openai_entry.delete(0, tk.END)
            openai_entry.insert(0, config["api_keys"].get("openai", ""))
            
            gemini_entry.delete(0, tk.END)
            gemini_entry.insert(0, config["api_keys"].get("gemini", ""))
            
            claude_entry.delete(0, tk.END)
            claude_entry.insert(0, config["api_keys"].get("claude", ""))
            
            deeseek_entry.delete(0, tk.END)
            deeseek_entry.insert(0, config["api_keys"].get("deepseek", ""))
            
            model_content_var.set(config["model_settings"].get("content_model", 0))
            model_image_var.set(config["model_settings"].get("image_model", 0))
            
            image_number_entry.delete(0, tk.END)
            image_number_entry.insert(0, config["model_settings"].get("images_per_post", ""))
            
            folder_entry.delete(0, tk.END)
            folder_entry.insert(0, config["model_settings"].get("images_folder", ""))
            
            url_entry.delete(0, tk.END)
            url_entry.insert(0, config["wordpress"].get("url", ""))
            
            username_entry.delete(0, tk.END)
            username_entry.insert(0, config["wordpress"].get("username", ""))
            
            password_entry.delete(0, tk.END)
            password_entry.insert(0, config["wordpress"].get("password", ""))
            
            data_input_entry.delete(0, tk.END)
            data_input_entry.insert(0, config["wordpress"].get("data_input", ""))
            
            posting_mode_var.set(config["posting"].get("mode", 1))

            chrome_profiles = config["model_settings"].get("chrome_profiles", ["", "", "", "", ""])
            for i, profile in enumerate(chrome_profiles):
                if i < len(chrome_profile_entries):
                    chrome_profile_entries[i].delete(0, tk.END)
                    chrome_profile_entries[i].insert(0, profile)

            if "internal_linking" in config:
                toggle_var.set(config["internal_linking"].get("enabled", False))
                toggle_switch()
                
                templates = config["internal_linking"].get("text_templates", ["", "", ""])
                text_entry1.delete(0, tk.END)
                text_entry1.insert(0, templates[0] if len(templates) > 0 else "")
                
                text_entry2.delete(0, tk.END)
                text_entry2.insert(0, templates[1] if len(templates) > 1 else "")
                
                text_entry3.delete(0, tk.END)
                text_entry3.insert(0, templates[2] if len(templates) > 2 else "")
                
                number_entry1.delete(0, tk.END)
                number_entry1.insert(0, config["internal_linking"].get("min_links", ""))
                
                number_entry2.delete(0, tk.END)
                number_entry2.insert(0, config["internal_linking"].get("max_links", ""))
            
            update_log(f"Đã tải cấu hình từ file: {os.path.basename(file_path)}")
        else:
            update_log(f"File không tồn tại: {file_path}")
    except Exception as e:
        update_log(f"Lỗi khi tải cấu hình: {str(e)}")

def test_post():
    def run():
        wordpress_url = url_entry.get().strip()
        username = username_entry.get().strip()
        password = password_entry.get()
        
        if not wordpress_url or not username or not password:
            update_log("Vui lòng nhập đầy đủ URL, username và password của WordPress")
            return
            
        update_log("Đang thử đăng bài lên WordPress...")
        
        selected_categories = []
        for widget in scrollable_frame.winfo_children():
            if isinstance(widget, tk.Checkbutton) and widget.var.get() == 1:
                category_id = widget.category_id
                selected_categories.append(category_id)
        
        if not selected_categories:
            update_log("Vui lòng chọn ít nhất một danh mục")
            return
            
        post_data = {
            'title': 'aaaa',
            'content': 'aaaa',
            'status': 'draft' if posting_mode_var.get() == 2 else 'publish',
            'categories': selected_categories
        }
        
        post_url = f"{wordpress_url}/wp-json/wp/v2/posts"
        
        try:
            response = requests.post(
                post_url,
                auth=HTTPBasicAuth(username, password),
                json=post_data,
                timeout=10
            )
            
            if response.status_code in [200, 201]:
                post_data = response.json()
                post_link = post_data.get('link', '')
                update_log(f"Bài viết đăng thành công! Link: {post_link}")
            else:
                update_log(f"Đăng bài thất bại. Mã lỗi: {response.status_code}")
                update_log(f"Nội dung lỗi: {response.text}")
        except Exception as e:
            update_log(f"Lỗi khi đăng bài: {str(e)}")
    
    threading.Thread(target=run).start()

def save_data():
    chrome_profiles = []
    for entry in chrome_profile_entries:
        chrome_profiles.append(entry.get().strip())
        
    config = {
        "api_keys": {
            "openai": openai_entry.get().strip(),
            "gemini": gemini_entry.get().strip(),
            "claude": claude_entry.get().strip(),
            "deepseek": deeseek_entry.get().strip()
        },
        "model_settings": {
            "content_model": model_content_var.get(),
            "image_model": model_image_var.get(),
            "images_per_post": image_number_entry.get().strip(),
            "images_folder": folder_entry.get().strip(),
            "chrome_profiles": chrome_profiles
        },
        "wordpress": {
            "url": url_entry.get().strip(),
            "username": username_entry.get().strip(),
            "password": password_entry.get(),
            "data_input": data_input_entry.get().strip()
        },
        "posting": {
            "mode": posting_mode_var.get()
        },
        "internal_linking": {
            "enabled": toggle_var.get(),
            "text_templates": [
                text_entry1.get().strip(),
                text_entry2.get().strip(),
                text_entry3.get().strip()
            ],
            "min_links": number_entry1.get().strip(),
            "max_links": number_entry2.get().strip()
        }
    }
    
    try:
        with open("wordpress_ai_config.json", "w", encoding="utf-8") as f:
            json.dump(config, f, indent=4)
        update_log("Cấu hình đã được lưu thành công!")
    except Exception as e:
        update_log(f"Lỗi khi lưu cấu hình: {str(e)}")

def load_saved_data():
    try:
        if os.path.exists("wordpress_ai_config.json"):
            with open("wordpress_ai_config.json", "r", encoding="utf-8") as f:
                config = json.load(f)
                
            openai_entry.delete(0, tk.END)
            openai_entry.insert(0, config["api_keys"].get("openai", ""))
            
            gemini_entry.delete(0, tk.END)
            gemini_entry.insert(0, config["api_keys"].get("gemini", ""))
            
            claude_entry.delete(0, tk.END)
            claude_entry.insert(0, config["api_keys"].get("claude", ""))
            
            deeseek_entry.delete(0, tk.END)
            deeseek_entry.insert(0, config["api_keys"].get("deepseek", ""))
            
            model_content_var.set(config["model_settings"].get("content_model", 0))
            model_image_var.set(config["model_settings"].get("image_model", 0))
            
            image_number_entry.delete(0, tk.END)
            image_number_entry.insert(0, config["model_settings"].get("images_per_post", ""))
            
            folder_entry.delete(0, tk.END)
            folder_entry.insert(0, config["model_settings"].get("images_folder", ""))
            
            url_entry.delete(0, tk.END)
            url_entry.insert(0, config["wordpress"].get("url", ""))
            
            username_entry.delete(0, tk.END)
            username_entry.insert(0, config["wordpress"].get("username", ""))
            
            password_entry.delete(0, tk.END)
            password_entry.insert(0, config["wordpress"].get("password", ""))
            
            data_input_entry.delete(0, tk.END)
            data_input_entry.insert(0, config["wordpress"].get("data_input", ""))
            
            posting_mode_var.set(config["posting"].get("mode", 1))

            chrome_profiles = config["model_settings"].get("chrome_profiles", ["", "", "", "", ""])
            for i, profile in enumerate(chrome_profiles):
                if i < len(chrome_profile_entries):
                    chrome_profile_entries[i].delete(0, tk.END)
                    chrome_profile_entries[i].insert(0, profile)
                    
            if "internal_linking" in config:
                toggle_var.set(config["internal_linking"].get("enabled", False))
                toggle_switch()
                
                templates = config["internal_linking"].get("text_templates", ["", "", ""])
                text_entry1.delete(0, tk.END)
                text_entry1.insert(0, templates[0] if len(templates) > 0 else "")
                
                text_entry2.delete(0, tk.END)
                text_entry2.insert(0, templates[1] if len(templates) > 1 else "")
                
                text_entry3.delete(0, tk.END)
                text_entry3.insert(0, templates[2] if len(templates) > 2 else "")
                
                number_entry1.delete(0, tk.END)
                number_entry1.insert(0, config["internal_linking"].get("min_links", ""))
                
                number_entry2.delete(0, tk.END)
                number_entry2.insert(0, config["internal_linking"].get("max_links", ""))
            
            update_log("Cấu hình đã được tải thành công!")
    except Exception as e:
        update_log(f"Lỗi khi tải cấu hình: {str(e)}")
def check_openai_api_key(api_key):
    try:
        client = OpenAI(api_key=api_key)
        response = client.models.list()
        return True, "API key OpenAI hợp lệ"
    except Exception as e:
        return False, f"API key OpenAI không hợp lệ: {str(e)}"

def check_gemini_api_key(api_key):
    try:
        genai.configure(api_key=api_key)
        
        available_models = genai.list_models()
        for model in available_models:
            model.name
        
        print("Danh sách các model có sẵn:")
        for model in available_models:
            print(f"- {model}")
        return True, "API key Gemini hợp lệ"
    except Exception as e:
        return False, f"API key Gemini không hợp lệ: {str(e)}"

def check_claude_api_key(api_key):
    try:
        client = Anthropic(api_key=api_key)
        response = client.messages.create(
            model="claude-3-haiku-20240307",
            max_tokens=10,
            messages=[{"role": "user", "content": "Hello, World!"}]
        )
        return True, "API key Claude hợp lệ"
    except Exception as e:
        return False, f"API key Claude không hợp lệ: {str(e)}"

def check_deepseek_api_key(api_key):
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    
    data = {
        "model": "deepseek-chat",
        "messages": [{"role": "user", "content": "Hello, World!"}],
        "max_tokens": 10
    }
    
    try:
        response = requests.post(
            "https://api.deepseek.com/v1/chat/completions",
            headers=headers,
            json=data
        )
        if response.status_code == 200:
            return True, "API key Deepseek hợp lệ"
        else:
            return False, f"API key Deepseek không hợp lệ: {response.text}"
    except Exception as e:
        return False, f"API key Deepseek không hợp lệ: {str(e)}"

def test_rest_api():
    def run():
        wordpress_url = url_entry.get().strip()
        if not wordpress_url:
            update_log("Vui lòng nhập URL của WordPress")
            return
            
        update_log("Đang kiểm tra REST API của WordPress...")
        
        rest_api_url = f"{wordpress_url}/wp-json/"
        
        try:
            response = requests.get(rest_api_url, timeout=10)
            if response.status_code == 200:
                update_log("REST API hoạt động tốt!")
            else:
                update_log(f"REST API không hoạt động. Mã lỗi: {response.status_code}")
        except Exception as e:
            update_log(f"Lỗi khi kết nối đến REST API: {str(e)}")
    
    threading.Thread(target=run).start()


def test_login():
    def run():
        wordpress_url = url_entry.get().strip()
        username = username_entry.get().strip()
        password = password_entry.get()
        
        if not wordpress_url or not username or not password:
            update_log("Vui lòng nhập đầy đủ URL, username và password của WordPress")
            return
            
        update_log("Đang kiểm tra đăng nhập WordPress...")
        
        login_test_url = f"{wordpress_url}/wp-json/wp/v2/users/me"
        
        try:
            response = requests.get(
                login_test_url, 
                auth=HTTPBasicAuth(username, password),
                timeout=10
            )
            
            if response.status_code == 200:
                user_data = response.json()
                update_log(f"Đăng nhập thành công! Xin chào {user_data.get('name', username)}")
            else:
                update_log(f"Đăng nhập thất bại. Mã lỗi: {response.status_code}")
                if response.status_code == 401:
                    update_log("Username hoặc password không chính xác")
        except Exception as e:
            update_log(f"Lỗi khi kiểm tra đăng nhập: {str(e)}")
    
    threading.Thread(target=run).start()

def load_category():
    def run():
        wordpress_url = url_entry.get()
        username = username_entry.get()
        password = password_entry.get()
        if not wordpress_url or not username or not password:
            update_log("Vui lòng nhập URL, username và password của WordPress")
            return
        else:
            update_log("Đang tải danh sách category...")
        
        categories = get_categories(wordpress_url, username, password)
        if categories:
            for widget in scrollable_frame.winfo_children():
                widget.destroy()
            
            for category in categories:
                var = tk.IntVar()
                cb = tk.Checkbutton(scrollable_frame, text=category['name'], bg="#f0f0f0", variable=var)
                cb.var = var
                cb.category_id = category['id']
                cb.pack(anchor='w')
                
        update_log("Danh sách category đã được tải")
    threading.Thread(target=run).start()

def get_categories(wordpress_url, username, password):
    categories_url = f"{wordpress_url}/wp-json/wp/v2/categories"
   
    response = requests.get(categories_url, auth=HTTPBasicAuth(username, password))
    
    if response.status_code == 200:
        categories = response.json()
        return categories
    else:
        print(f"Failed to retrieve categories: {response.status_code}")
        return None
def update_log(message):
    log_text.configure(state='normal')
    log_text.insert(tk.END, message + "\n")
    log_text.see(tk.END)
    log_text.configure(state='disabled')

def test_openai_api():
    def run():
        api_key = openai_entry.get().strip()
        if not api_key:
            update_log("Please enter an OpenAI API key")
            return
            
        update_log("Testing OpenAI API key...")
        success, message = check_openai_api_key(api_key)
        
        if success:
            update_log("Success: " + message)
        else:
            update_log("Error: " + message)
    threading.Thread(target=run).start()


def test_gemini_api():
    api_key = gemini_entry.get().strip()
    if not api_key:
        update_log("Please enter a Gemini API key")
        return
        
    update_log("Testing Gemini API key...")
    success, message = check_gemini_api_key(api_key)
    
    if success:
        update_log("Success: " + message)
    else:
        update_log("Error: " + message)

def test_claude_api():
    api_key = claude_entry.get().strip()
    if not api_key:
        update_log("Please enter a Claude API key")
        return
        
    update_log("Testing Claude API key...")
    success, message = check_claude_api_key(api_key)
    
    if success:
        update_log("Success: " + message)
    else:
        update_log("Error: " + message)

def test_deepseek_api():
    def run():
        api_key = deeseek_entry.get().strip()
        if not api_key:
            update_log("Please enter a Deepseek API key")
            return
            
        update_log("Testing Deepseek API key...")
        success, message = check_deepseek_api_key(api_key)
        
        if success:
            update_log("Success: " + message)
        else:
            update_log("Error: " + message)
    threading.Thread(target=run).start()




def choose_file():
    file_path = filedialog.askopenfilename(
        title="Chọn File Excel",
        filetypes=[
            ("Excel Files", "*.xlsx *.xls"),
            ("All Files", "*.*")
        ]
    )
    if file_path:
        data_input_entry.delete(0, tk.END)
        data_input_entry.insert(0, file_path)
        update_log(f"Đã chọn file Excel: {os.path.basename(file_path)}")

def choose_folder():
    folder_path = filedialog.askdirectory(
        title="Chọn Thư Mục Lưu Ảnh AI"
    )
    if folder_path:
        folder_entry.delete(0, tk.END)
        folder_entry.insert(0, folder_path)
        update_log(f"Đã chọn thư mục lưu ảnh: {folder_path}")
    else:
        update_log("Không có thư mục nào được chọn")

root = tk.Tk()
root.title("Post WordPress")
root.geometry("1200x750")

api_frame = tk.Frame(root, bg="#f0f0f0", bd=2, relief="groove")
api_frame.place(x=30, y=30, width=1120, height=110)

tk.Label(api_frame, text="THIẾP LẬP API", font=("Arial", 14), bg="#f0f0f0").place(x=10, y=10)
tk.Label(api_frame, text="OPEN AI", bg="#f0f0f0").place(x=20, y=40)
openai_entry = tk.Entry(api_frame, width=40)
openai_entry.place(x=100, y=40)
tk.Button(api_frame, text="TEST API", command=test_openai_api).place(x=430, y=35)

tk.Label(api_frame, text="GEMINI", bg="#f0f0f0").place(x=20, y=70)
gemini_entry = tk.Entry(api_frame, width=40)
gemini_entry.place(x=100, y=70)
tk.Button(api_frame, text="TEST API", command=test_gemini_api).place(x=430, y=65)

tk.Label(api_frame, text="CLAUDE", bg="#f0f0f0").place(x=600, y=40)
claude_entry = tk.Entry(api_frame, width=40)
claude_entry.place(x=680, y=40)
tk.Button(api_frame, text="TEST API", command=test_claude_api).place(x=1010, y=35)

tk.Label(api_frame, text="DEESEEK", bg="#f0f0f0").place(x=600, y=70)
deeseek_entry = tk.Entry(api_frame, width=40)
deeseek_entry.place(x=680, y=70)
tk.Button(api_frame, text="TEST API", command=test_deepseek_api).place(x=1010, y=65)

model_frame = tk.Frame(root, bg="#f0f0f0", bd=2, relief="groove")
model_frame.place(x=30, y=150, width=1120, height=140)

tk.Label(model_frame, text="CHỌN MODEL CONTENT", font=("Arial", 14), bg="#f0f0f0").place(x=10, y=10)

model_content_var = tk.IntVar()

tk.Radiobutton(model_frame, text="CHATGPT 4.0", bg="#f0f0f0", variable=model_content_var, value=1).place(x=20, y=40)
tk.Radiobutton(model_frame, text="4.0-mini", bg="#f0f0f0", variable=model_content_var, value=2).place(x=20, y=70)
tk.Radiobutton(model_frame, text="4.5", bg="#f0f0f0", variable=model_content_var, value=3).place(x=20, y=100)
tk.Radiobutton(model_frame, text="CLAUDE 3.5", bg="#f0f0f0", variable=model_content_var, value=4).place(x=140, y=40)
tk.Radiobutton(model_frame, text="3.7", bg="#f0f0f0", variable=model_content_var, value=5).place(x=140, y=70)
tk.Radiobutton(model_frame, text="DEESEEK V2", bg="#f0f0f0", variable=model_content_var, value=6).place(x=260, y=40)
tk.Radiobutton(model_frame, text="V3", bg="#f0f0f0", variable=model_content_var, value=7).place(x=260, y=70)
tk.Radiobutton(model_frame, text="R1", bg="#f0f0f0", variable=model_content_var, value=8).place(x=260, y=100)

tk.Label(model_frame, text="CHỌN MODEL ẢNH", font=("Arial", 14), bg="#f0f0f0").place(x=600, y=10)

model_image_var = tk.IntVar()

tk.Radiobutton(model_frame, text="DALLE-3", bg="#f0f0f0", variable=model_image_var, value=1).place(x=600, y=40)
tk.Radiobutton(model_frame, text="IMAGEN3", bg="#f0f0f0", variable=model_image_var, value=2).place(x=720, y=40)
tk.Radiobutton(model_frame, text="MIDJONEY", bg="#f0f0f0", variable=model_image_var, value=3).place(x=840, y=40)

tk.Label(model_frame, text="Số ảnh cần tạo trong 1 bài viết", bg="#f0f0f0").place(x=600, y=70)
image_number_entry = tk.Entry(model_frame, width=10)
image_number_entry.place(x=840, y=70)

tk.Label(model_frame, text="FOLDER ẢNH", bg="#f0f0f0").place(x=600, y=100)
folder_entry = tk.Entry(model_frame, width=40)
folder_entry.place(x=680, y=100)
tk.Button(model_frame, text="Chọn Folder", command=choose_folder).place(x=1010, y=95)

tk.Label(model_frame, text="Số ảnh cần tạo trong 1 bài viết", bg="#f0f0f0").place(x=600, y=70)
image_number_entry = tk.Entry(model_frame, width=10)
image_number_entry.place(x=840, y=70)

tk.Label(model_frame, text="FOLDER ẢNH", bg="#f0f0f0").place(x=600, y=100)
folder_entry = tk.Entry(model_frame, width=40)
folder_entry.place(x=680, y=100)
tk.Button(model_frame, text="Chọn Folder", command=choose_folder).place(x=1010, y=95)

wordpress_category_frame = tk.Frame(root, bg="#f0f0f0", bd=2, relief="groove")
wordpress_category_frame.place(x=30, y=300, width=1120, height=180)

wordpress_frame = tk.Frame(wordpress_category_frame, bg="#f0f0f0")
wordpress_frame.place(x=10, y=10, width=540, height=160)

tk.Label(wordpress_frame, text="THIẾT LẬP WORDPRESS", font=("Arial", 14), bg="#f0f0f0").place(x=10, y=10)
tk.Label(wordpress_frame, text="URL", bg="#f0f0f0").place(x=20, y=35)
url_entry = tk.Entry(wordpress_frame, width=40)
url_entry.place(x=100, y=35)
tk.Button(wordpress_frame, text="TEST REST API", command=test_rest_api).place(x=430, y=30)


tk.Label(wordpress_frame, text="USERNAME", bg="#f0f0f0").place(x=20, y=65)
username_entry = tk.Entry(wordpress_frame, width=40)
username_entry.place(x=100, y=65)

tk.Label(wordpress_frame, text="PASS", bg="#f0f0f0").place(x=20, y=95)
password_entry = tk.Entry(wordpress_frame, show="*", width=40)
password_entry.place(x=100, y=95)
tk.Button(wordpress_frame, text="TEST LOGIN", command=test_login).place(x=430, y=90)


tk.Label(wordpress_frame, text="DATA INPUT", bg="#f0f0f0").place(x=20, y=125)
data_input_entry = tk.Entry(wordpress_frame, width=40)
data_input_entry.place(x=100, y=125)
tk.Button(wordpress_frame, text="Chọn file", command=choose_file).place(x=430, y=120)

category_frame = tk.Frame(wordpress_category_frame, bg="#f0f0f0")
category_frame.place(x=570, y=10, width=540, height=160)

tk.Label(category_frame, text="LOAD CATEGORY", font=("Arial", 14), bg="#f0f0f0").place(x=10, y=10)
tk.Button(category_frame, text="LOAD CATEGORY", command=load_category).place(x=20, y=40)

scrollable_container = tk.Frame(category_frame, bg="#f0f0f0", bd=1, relief="solid")
scrollable_container.place(x=200, y=10, width=330, height=100)

canvas = tk.Canvas(scrollable_container, bg="#f0f0f0", width=350, height=78)
scrollbar = tk.Scrollbar(scrollable_container, orient="vertical", command=canvas.yview)
scrollable_frame = tk.Frame(canvas, bg="#f0f0f0", width=330)

def configure_scrollregion(event):
    canvas.configure(scrollregion=canvas.bbox("all"))

scrollable_frame.bind("<Configure>", configure_scrollregion)

canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
canvas.configure(yscrollcommand=scrollbar.set)

canvas.grid(row=0, column=0, sticky="nsew")
scrollbar.grid(row=0, column=1, sticky="ns")

scrollable_container.grid_rowconfigure(0, weight=1)
scrollable_container.grid_columnconfigure(0, weight=1)

def _on_mousewheel(event):
    canvas.yview_scroll(int(-1*(event.delta/70)), "units")

canvas.bind_all("<MouseWheel>", _on_mousewheel)

tk.Label(category_frame, text="CHẾ ĐỘ ĐĂNG", font=("Arial", 14), bg="#f0f0f0").place(x=10, y=130)

posting_mode_var = tk.IntVar()

tk.Radiobutton(category_frame, text="Public (công khai)", bg="#f0f0f0", variable=posting_mode_var, value=1).place(x=160, y=130)
tk.Radiobutton(category_frame, text="Draf (nháp)", bg="#f0f0f0", variable=posting_mode_var, value=2).place(x=280, y=130)

action_log_frame = tk.Frame(root, bg="#f0f0f0", bd=2)
action_log_frame.place(x=30, y=490, width=1120, height=180)

action_frame = tk.Frame(action_log_frame, bg="#f0f0f0")
action_frame.place(x=10, y=10, width=1100, height=160)

tk.Label(model_frame, text="Chrome Profiles for Imagen3:", bg="#f0f0f0").place(x=600, y=140)

chrome_profiles_frame = tk.Frame(root, bg="#f0f0f0", bd=2, relief="groove")
chrome_profiles_frame.place(x=30, y=300, width=1120, height=130)

chrome_profile_entries = []
for i in range(5):
    tk.Label(chrome_profiles_frame, text=f"Chrome Profile {i+1}:", bg="#f0f0f0").place(x=20, y=10 + i*22)
    entry = tk.Entry(chrome_profiles_frame, width=70)
    entry.place(x=130, y=10 + i*22)
    chrome_profile_entries.append(entry)
    tk.Button(chrome_profiles_frame, text="Browse", command=lambda idx=i: choose_chrome_profile(idx)).place(x=600, y=8 + i*22)

additional_frame = tk.Frame(root, bg="#f0f0f0", bd=2)
additional_frame.place(x=700, y=310, width=400, height=100)
text_entry1 = tk.Entry(additional_frame, width=30)
text_entry1.place(x=100, y=10)
text_entry2 = tk.Entry(additional_frame, width=30)
text_entry2.place(x=100, y=40)
text_entry3 = tk.Entry(additional_frame, width=30)
text_entry3.place(x=100, y=70)

def toggle_switch():
    if toggle_var.get():
        toggle_canvas.itemconfig(toggle_circle, fill="green")
        toggle_canvas.coords(toggle_circle, 30, 5, 50, 25)
    else:
        toggle_canvas.itemconfig(toggle_circle, fill="red")
        toggle_canvas.coords(toggle_circle, 5, 5, 25, 25)

toggle_var = tk.BooleanVar(value=False)
toggle_canvas = tk.Canvas(additional_frame, width=55, height=30, bg="#f0f0f0", highlightthickness=0)
toggle_canvas.place(x=10, y=40)

toggle_canvas.create_rectangle(5, 5, 50, 25, fill="#ccc", outline="")
toggle_circle = toggle_canvas.create_oval(5, 5, 25, 25, fill="red", outline="")

toggle_canvas.bind("<Button-1>", lambda event: toggle_var.set(not toggle_var.get()) or toggle_switch())

tk.Label(additional_frame, text="Số 1:", bg="#f0f0f0").place(x=200, y=100)
number_entry1 = tk.Entry(additional_frame, width=5)
number_entry1.place(x=300, y=40)

tk.Label(additional_frame, text="Số 2:", bg="#f0f0f0").place(x=300, y=100)
number_entry2 = tk.Entry(additional_frame, width=5)
number_entry2.place(x=350, y=40)

wordpress_category_frame.place(x=30, y=440, width=1120, height=180)
action_log_frame.place(x=30, y=630, width=1120, height=180)

def choose_chrome_profile(idx):
    folder_path = filedialog.askdirectory(
        title=f"Select Chrome Profile {idx+1} Directory"
    )
    if folder_path:
        chrome_profile_entries[idx].delete(0, tk.END)
        chrome_profile_entries[idx].insert(0, folder_path)
        update_log(f"Chrome profile {idx+1} set to: {folder_path}")


tk.Button(action_frame, text="BẮT ĐẦU", bg="green", width=16, command=start_processing).place(x=20, y=20)
tk.Button(action_frame, text="TEST ĐĂNG", bg="yellow", width=16, command=test_post).place(x=180, y=20)
tk.Button(action_frame, text="DỪNG CHẠY", bg="red", width=16, command=stop_processing).place(x=20, y=60)
tk.Button(action_frame, text="LƯU DỮ LIỆU", bg="orange", width=16, command=save_data).place(x=180, y=60)
tk.Button(action_frame, text="TẢI DỮ LIỆU", bg="lightblue", width=16, command=load_data).place(x=340, y=20)
tk.Button(action_frame, text="THOÁT PHẦN MỀM", bg="pink", width=16).place(x=340, y=60)

log_text = tk.Text(action_frame, state='disabled', bg="#f0f0f0", wrap='word')
log_text.place(x=600, y=10, width=450, height=80)
update_log("Lưu ý: Không mở file excel trong thời gian chạy, tránh bị lỗi lưu data")

root.mainloop()
